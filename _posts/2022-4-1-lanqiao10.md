---
title: 第十届蓝桥杯真题题解
date: 2022-4-2 12:13:31 +0800
tags: [蓝桥杯,题解,算法]
categories: [题解,蓝桥杯]
---

### 研究生组：

#### 试题A：立方和

> 暴力搜索。

```c++
#include<iostream>

using namespace std;

int main() {
	long long  sum = 0;
	for (int i = 1; i <= 1; i++) {
		//下面代码是对个位数进行判断
		if (i % 10 == 2 || i % 10 == 0 || i % 10 == 1 || i % 10 == 9)
		{
			cout << i << endl;
			sum = sum + i * i * i;
			continue;
		}
		//下面代码是对十位数进行判断
		if (i >= 10) {
			if ((i / 10) % 10 == 2 || (i / 10) % 10 == 0 || (i / 10) % 10 == 1 || (i / 10) % 10 == 9) {
				sum = sum + i * i * i;
				cout << i << endl;
				continue;
			}
		}
		//下面代码是对百位数进行判断
		if (i >= 100) {
			if ((i / 100) % 10 == 2 || (i / 100) % 10 == 0 || (i / 100) % 10 == 1 || (i / 100) % 10 == 9)
			{
				cout << i << endl;
				sum = sum + i * i * i;
				continue;
			}
		}
		//下面代码是对千位数进行判断
		if (i >= 1000)
		{
			if ((i / 1000) % 10 == 2 || (i / 1000) % 10 == 0 || (i / 1000) % 10 == 1 || (i / 1000) % 10 == 9)
			{
				cout << i << endl;
				sum = sum + i * i * i;
				continue;
			}
		}
	}

	cout << sum << endl;
	return 0;
}
```

#### 试题B：字串数字

> 暴力搜索，相当于26进制，字符串操作。

```c++
#include<iostream>
#include<cmath>
#include<string>

using namespace std;

int main() {
	string s;
	cin >> s;

	long long sum = 0;
	for (int i = 0; i < s.length(); ++i) {
		sum += (s[i] - 'A' + 1) * pow(26, s.length() - 1 - i);
	}

	cout << sum;
	return 0;
}
```

#### 试题C：质数

> 暴力搜索，遇到一个质数计数加1，输出第2019个即可。

```c++
#include<iostream>

using namespace std;

// 判断是否是质数
bool Prime(int a) {
	int nums = 0;
	for (int i = 1; i <= a; ++i) {
		if (a % i == 0)
			++nums;
	}

	if (nums > 2)
		return false;
	else
		return true;
}

int main() {
	int inf = 0x3f3f3f3f;

	int count = 0;
	for (int i = 2; i <= inf; ++i) {
		if (Prime(i))
			++count;
		if (count == 2019) {
			cout << count << endl;
			cout << i;
			break;
		}		
	}

	return 0;
}
```

#### 试题D：最短路

> dijkstra，[算法模板](https://blog.csdn.net/YMWM_/article/details/115497375)。

```c++
#include<iostream>

using namespace std;

int ver[20][20];  // 顶点 ver[i][j]表示i j之间的距离
int dist[20];  // 距离 dist[i]表示i到起点的最短距离
bool known[20];  // 标记 是否被处理过
int n = 19;  // 题目顶点数

// dijkstra
int Dijkstra() {
	memset(dist, 0x3f, sizeof(dist));  // 距离初始化为inf
	dist[1] = 0;  // 第一个顶点距离为0 自己到自己的距离

	// 遍历所有顶点
	for (int i = 0; i < n; ++i) {
		int t = -1;
		// 遍历寻找距离最近的下一个顶点
		for (int j = 1; j <= n; ++j) {
			if (!known[j] && (t == -1 || dist[t] > dist[j]))
				t = j;
		}

		// 更新最小距离
		for (int j = 1; j <= n; ++j) {
			dist[j] = min(dist[j], dist[t] + ver[t][j]);
		}

		// 更新标记
		known[t] = true;
	}
	
	return dist[19];
}

// 初始化边
void Add(int a, int b, int c) {
	ver[a][b] = ver[b][a] = c;
}

// 单源最短路径问题：给定一个加权图和一个特定顶点作为输入
// 找到从输入到图中任意一个顶点的最短加权路径
int main() {
	memset(ver, 0x3f, sizeof(ver));

	// 根据图中的边初始化
	Add(1, 2, 2);
	Add(1, 3, 1);
	Add(1, 4, 1);
	Add(1, 5, 1);
	Add(2, 7, 1);
	Add(2, 10, 2);
	Add(3, 6, 3);
	Add(3, 7, 3);
	Add(3, 4, 3);
	Add(4, 5, 1);
	Add(4, 7, 2);
	Add(4, 8, 1);
	Add(4, 9, 2);
	Add(5, 8, 1);
	Add(5, 9, 3);
	Add(6, 7, 1);
	Add(6, 10, 1);
	Add(7, 9, 3);
	Add(7, 11, 2);
	Add(8, 9, 1);
	Add(8, 12, 2);
	Add(9, 13, 3);
	Add(10, 19, 2);
	Add(11, 12, 3);
	Add(11, 14, 1);
	Add(11, 16, 2);
	Add(12, 13, 1);
	Add(12, 18, 1);
	Add(13, 17, 1);
	Add(13, 19, 1);
	Add(13, 14, 2);
	Add(14, 16, 1);
	Add(15, 16, 1);
	Add(15, 17, 1);
	Add(15, 18, 3);
	Add(18, 19, 1);

	cout << Dijkstra() << endl;
	return 0;
}
```

#### [试题E：RSA解密](https://blog.csdn.net/u013377068/article/details/88779236)

> 几何题，用暴力搜索时间很慢，需要扩展欧几里何、快速幂、快速乘。

```c++
// 放个思路 这个算不出来
#include<iostream>
#include<cmath>

using namespace std;

typedef long long ll;

// 互质表示两个数的最大公约数为1
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

bool Prime(int a) {
	int count = 0;
	for (int i = 1; i <= a; ++i) {
		if (a % i == 0)
			++count;
	}
	if (count > 2)
		return false;
	else
		return true;
}

int main() {
	ll n = 1001733993063167141;
	int d = 212353;
	int c = 20190324;

	// 找到那两个质数
	ll p = 0, q = 0;
	for (ll i = 1; i <= n; ++i) {
		if (Prime(i) && Prime(n / i)) {
			p = i;
			q = n / i;
			break;
		}
	}

	ll p = 7, q = 143104856151881020;
	// 计算e
	ll e = 0;
	if (gcd(d, (p - 1) * (q - 1)) == 1) {
		for (ll i = 1; i <= n; ++i) {
			if ((p - 1) * (q - 1) % (i * d) == 1) {
				e = i;
				break;
			}	
		}
	}

	// 解密
	ll x = 0;
	x = pow(c, e);
	x = x % n;
	cout << x;

	return 0;
}
```

#### 试题F：Fibonacci数列与黄金分割

>这题需要找规律，那么大的数算不出来，大于20之后结果就一样了。

```c++
#include<iostream>

using namespace std;

typedef long long ll;
int dp[25];
int main() {	
	dp[1] = 1;
	dp[2] = 2;
	for (int i = 3; i < 25; ++i) {
		dp[i] = dp[i - 1] + dp[i - 2];
		
	}

	double ans = 0.0;
	ans = (double)dp[23] / (double)dp[24];
	printf("%.8f", ans);
	return 0;
}
```

#### [试题G：扫地机器人](https://blog.51cto.com/u_15487307/5096859)

> 二分+贪心，较难。

#### [试题H：修改数组](https://blog.csdn.net/m0_51474171/article/details/123742312)

> 直接暴力会超时，并查集。















### 大学组：






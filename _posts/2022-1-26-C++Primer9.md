---

title: C++Primer5 第9章 顺序容器
date: 2022-1-26 10:33:39 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++]

---

**说明：** 本章是第3章内容的扩展，是对标准库顺序容器的扩展；第11章将介绍标准库关联容器。

> 由于本章中设计大量的容器操作，短时间内不可能全部掌握，也没有必要死磕，重点要放在一些常用的操作，剩下的等用到时再查表就行了。

顺序容器、关联容器区别？

> 顺序容器提供控制元素存储和访问顺序的能力，这种顺序不依赖于元素的值，而是与元素加入容器时的位置想对应。而第11章中的有序和无序关联容器，则根据关键字的值来存储元素。

### 顺序容器概述

1、所有顺序容器都提供了两种能力，并且需要在两种能力中折中。

* 控制元素存储：向容器中添加、删除元素的代价。
* 控制访问顺序：非顺序访问容器中元素的代价。

2、C++顺序容器类型：

```c++
vector		// 可变大小数组 
    		// 支持快速随机访问 
    		// 在尾部插入、删除速度快 在尾部之外的位置插入或删除元素可能很慢
string      // 与vector相似 专用于保存字符 
    		// 支持快速随机访问
    		// 在尾部插入、删除速度快 在尾部之外的位置插入或删除元素可能很慢

list		// 单向链表
    		// 只支持单向顺序访问 不支持随机访问
    		// 任何位置插入、删除元素的操作速度都很快
forward_list// 双向链表
    		// 只支持单向顺序访问 不支持随机访问
    		// 任何位置插入、删除元素的操作速度都很快
    
deque  		// 双端队列
    		// 支持快速随机访问
    		// 在头尾插入、删除元素很快 其它位置插入或删除元素可能很慢
 
array 		// 固定大小数组
    		// 支持快速随机访问
    		// 不能添加、删除元素
```

3、C++应使用标准库容器，而非原始的数据结构，如内置数组等。

> 新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好，通常会更好！

4、通常，使用vector是最好的选择，除非你有很好的理由选择其它容器。

### 容器库概览

本节介绍对所有容器都使用的操作。

顺序容器几乎可以保存任意类型的元素，其元素也可以是另一个容器。

#### 迭代器

1、与容器一样，迭代器有着公共的接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的。

2、迭代器范围：[begin, end)，分别指向首元素和尾后元素。具有以下性质：

* 如果begin==end，则范围为空。
* 如果begin!=end，则范围至少包含一个元素，且begin指向第一个元素。
* 可以对begin递增若干次，使begin==end。

#### 容器类型成员

size_type、iterator、const_iterator

```c++
string::size_type;
vector<int>::iterator;
vector<int>::const_iterator;
```

#### bengin和end成员

rbegin、rend：反向迭代器

cbegin、cend：const迭代器，当不需要写访问时，用这个

#### 容器定义和初始化

1、默认初始化

每个容器类型都定义了一个默认构造函数，除array之外，其它容器的默认构造函数都会创建一个指定类型的空容器，并且都可以接受指定容器大小和元素初始值的参数。

2、拷贝初始化

* 直接拷贝初始化：两个容器的容器类型和元素类型都必须相同。
* 由迭代器指定元素范围拷贝：不要求容器类型相同，元素类型也可以不同，但必须能够隐式转换。此外，由于两个迭代器表示一个范围，也可以使用此种方法拷贝一个容器的子序列。

```c++
vector<const char*> vec = { "a", "an", "the" };
forward_list<string> words(vec.begin(), vec.end());  // 正确 const char*转换string 
```

3、列表初始化

`{}`进行列表初始化

`()`提供容器大小和元素初始值（可选），进行值初始化。

> 只有顺序容器的构造函数才接受大小参数，并联容器不支持！！！

4、标准库array具有固定大小

* 与内置数组一样，array的大小也是类型的一部分，定义array使，要指定元素类型和大小。

* 与内置数组不同的是，我们可以对array进行拷贝或对象赋值操作！

* 由于右边运算对象的大小和左边运算对象的大小不同，因此array不支持assign，也不允许用花括号包围的值列表进行赋值。

```c++
array<int, 42> arr;  // 42个默认初始化的int
array<int, 10> digits = { 0,1,2,3,4,5,6,7,8,9 };
array<int, 10> copy = digits;  // 正确 只要数组类型匹配即可
digits = {0};  // 错误
```

#### 赋值和swap

1、拷贝赋值和列表赋值

```c++
c1 = c2;  // 将c1的内容替换为c2中元素的拷贝 左边容器将与右边容器相等
c1 = { a, b, c };  // 赋值后 c1的大小变为3
```

2、`assign`赋值

不适用于并联容器和array。

```c++
seq.assign(b, e);  // seq中的元素替换为迭代器b和e所表示范围中的元素
seq.assign(n, t);  // 将seq中的元素替换为n个值为t的元素
```

3、使用`swap`

```c++
swao(c1, c2);  // 在泛型编程中非常重要 统一使用非成员版本！！！
c1.swap(c2);  // 早期标准库只提供成员版本
```

除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。通常比拷贝赋值快得多！

#### 容器大小操作

size：返回容器中元素的数目。

empty：size=0，返回true，也就是判断容器中有无元素。

max_size：返回一个大于或等于该类型容器所能容纳的最大元素数的值。但是容器不一定保证能达到该大小，可能还未达到该大小的时候，就已经无法继续分配内存空间了。

#### 关系运算符

1、每个容器类型都支持==和!=，除了无序关联容器外的所有容器都支持关系运算符（>、>=、<、<=）。关系运算符两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。容器的比较方式和string一样。

2、容器的相等运算符实际上是使用元素的相等运算符实现的，而其它关系运算符是使用元素的<运算符。如果元素类型不支持所需运算符，那么相应容器也就不能使用相应的关系运算。

```c++
vector<Sales_data> A,B;
if (A < B)  // 错误 Sales_data没有<运算符
```

### 顺序容器操作

#### 插入元素

##### push_back

1、除array和forward_list之外，每个顺序容器都支持push_back。

2、用一个对象来初始化容器时，或者将一个对象插入到容器中，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。正如值传递一样，我们对容器中元素的任何改变不会影响到原始对象。

##### push_front

list、forward_list、和deque支持push_front，将元素插入到容器头部。

##### insert

vector、string、deque、list都支持insert成员，forward_list提供了特殊版本的insert。

1、每个insert都接受一个迭代器作为其第一个参数，迭代器指定了在容器什么位置放置新元素，它可以指向容器中任何位置，包括容器尾部之后的下一个位置。insert将元素插入到迭代器指定的位置之前。

2、我们可以将元素insert到容器的开始位置，而不用担心容器是否支持push_front，但这样做可能很耗时。

3、insert可以插入范围内元素：

```c++
vec.insert(vec.end(), 10, "anna");  // 插入若干个元素到指定位置之前
list.insert(list.begin(), v.end()-1, v.end()); // 插入迭代器范围内的元素 不能指向相同容器
```

4、使用insert的返回值：

可以使用insert的返回值在容器中的一个特定位置反复插入元素，每次将元素插入到指定迭代器之前，然后返回的迭代器恰好指向这个新元素！

```c++
list<string> lst;
auto iter = lst.begin();
while (cin >> word)
    iter = lst.insert(iter, word);  // 等价于调用push_front
```

##### emplace

1、当我们使用emplace成员函数时，将参数传递给元素类型的构造函数，利用这些参数在容器管理的内存空间中直接构造元素。也就是说，使用emplace_back时，会在容器管理的内存空间中直接创建对象，而调用push_back时则会创建一个局部临时对象，并将其压入容器。

```c++
// 在c的末尾插入一个Sales_data对象
c.emplace_back("123", 25, 15.99);  // 使用三个参数的Sales_date构造函数
c.push_back("123", 25, 15.99);  // 错误 没有接受三个参数的push_back版本
c.push_back(Sales_data("123", 25, 15.99));  // 正确 创建一个临时对象传递给push_back
```

2、因为emplace函数在容器中直接构造元素，所以传递给emplace函数的参数必须与元素类型的构造函数相匹配，也就是说，要有相应类型的构造函数能够根据参数创建对象。

#### 访问元素

如果容器中没有元素，访问操作的结果是未定义的。前面已经知道可以通过解引用迭代器返回容器元素。

下面说的访问成员函数返回的都是引用。

##### front和back

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数，因为单向链表只允许单向顺序访问。

##### 下标运算符和at

at和下标只适用于string、vector、deque和array，也就是支持随机访问的容器。

```c++
c.front();
c.end();
c[n];
c.at(n);
```

#### 删除操作

##### pop_front和pop_back()

与访问成员函数类似，不能对一个空容器执行弹出操作。

##### erase

从容器内部删除一个或指定范围内的元素，返回指向删除的最后一个元素之后位置的迭代器。

```c++
list<int> lst = { i, j };
lst.erase(i);  // 返回指向j的迭代器
```

##### clear

删除容器中的所有元素，也可以以begin和end获得的迭代器调用erase。

#### 特殊forward_list操作

定义了insert_after、emplace_after、erase_after来代替相应的成员函数，并定义before_begin首前元素。

#### 改变容器大小

resize来增大和缩小容器，如果当前大小大于缩减后的，那么容器后部的元素会被删除；如果小于扩增后的，会将新元素添加到容器后补。

```c++
list<int> lst(10, 42);
lst.resize(15);  // 将5个值为0的元素添加到lst的末尾
lst.resize(25, -1);  // 将10个-1添加到lst的末尾
lst.resize(5);  // 删除lst后部20个元素
```

#### 容器操作可能使迭代器生效

使用失效的迭代器、指针或引用是严重的运行时错误，因此必须保证每次改变容器的操作之后都正确地重新定位（更新）迭代器。

1、调用erase之后，不必递增迭代器，因为erase返回的迭代器已经指向容器中的下一个元素。

2、调用insert之后，迭代器要递增两次，因为insert在指定元素之前插入。

3、循环过程中必须反复调用end，因为插入删除元素会使原来的end失效。

### vector对象如何增长

减少容器空间重新分配策略：当不得不获得新的内存时，vector和string通常分配比新的空间需求更大的内存空前，预留这些空间以备用。

#### reserve和resize

1、reserve永远不会减少容器占用的内存空间，至少分配和需求一样大的空间，可能更大。

2、resize只改变容器中元素的数目，而不是容器的容量。

#### capacity和size

1、size指定已经保存的元素的数目。

2、capacity是在不分配新的内存空间下它最多可以保存多少元素。

#### shrink_to_fit

将capacity减少为与size相同大小，退还多余的内存，只是一个请求，标准库并不保证退还。

### 额外的string操作

#### 构造string的其它方法

```c++
string s(cp, n);  // s是cp数组中前n个字符的拷贝
string s(s2, pos2);  // s是string s2从下标pos2开始的字符的拷贝
string s(s2, pos2, len2);  // s是string s2从下标pos2开始的len2个字符的拷贝
s.substr(pos, n);  // 返回一个string 包含s中从pos开始的n个字符的拷贝
```

#### 改变string的其它方法

```c++
s.append(args);  // 将args追加到s 
s.replace(range, args);  // 删除s范围range内的字符 替换为args 
						 // range可以是一个下标和一个长度 也可以是一对指向s的迭代器
```

#### string搜索操作

1、find函数完成最简单的搜索，查找参数指定的字符串，若找到，返回第一个匹配位置的下标，否则返回npos，npos为unsigned并且初始化为-1，这意味着npos十分大。

> 搜索对大小写敏感。

2、更复杂的问题就是查找与给定字符串中任何一个字符匹配的位置。

```c++
string numbers("0123456789"), name("r2dw");
auto pos = name.find_first_of(numbers);  // 从name中定位第一个数字！
```

3、指定从哪里开始搜索，可以传递给find一个可选的开始位置，指定从哪个位置开始搜索。

一个常用的技巧就是在字符串中循环的搜索子字符串出现的所有位置！！！

```c++
string s = "abababab";
size_t pos = 0;
//int index = s.find('a', pos);  // 从pos处查找指定字符
//cout << index;
while ((pos = s.find('a', pos)) != string::npos) {
    cout << "index is " << pos << ", element is " << s[pos] << endl;
    ++pos;  // 移动到下一个字符 避免无限循环
}
```

4、可以使用rfind进行逆向搜索。

#### compare函数

```c++
s.compare();
s2;  //比较s和s2
pos1, n1, s2;  // s从pos1开始的n1个字符与s2比较
pos1, n1, s2, pos2, n2;  // 同理

cp;  // cp是以空字符结尾的字符数组
pos1, n1, cp;  // 同理
pos1, n1, cp, n2;  // 与指针cp指向的地址开始的n2个字符进行比较
```

#### 数值转换

```c++
to_string(val);  // 一组重载函数 返回数值val的string表示 val可以使任意算术类型
stoi(s, p, b);  // 将字符串s从位置p处以b进制转换为int 
string str = "1010";
int a = stoi(str, 0, 2);  // a=10
```

### 容器适配器

标准库定义了三个顺序容器适配器：stack、queue和priority_queue。一个适配器就是一种机制，可以使某些事物的行为看起来像另外一种事物一样。

#### 定义适配器

每个适配器都定义两个构造函数：默认构造函数和拷贝构造函数。

#### 栈适配器

stack类型定义在相应头文件中。

```c++
// 栈默认基于deque实现 也可以在list和vector上实现
s.push();  
s.pop();
s.emplace();
s.top();  // 栈顶元素
```

#### 队列适配器

queue和priority_queue定义在queue头文件中。

```c++
q.push();
q.pop();
p.front();
q.back();  // queue由deque实现 因此只适用于queue
q.top();  // 返回最高优先级元素 有优先级 只适用于priority_queue
```



